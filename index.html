<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index 3</title>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.6.0/dist/aframe-extras.min.js"></script>  

    <script>
        // === Gesture Detector ===
        AFRAME.registerComponent("gesture-detector", {
        init: function () {
            this.internalState = { previousState: null };
            const canvas = this.el.sceneEl.canvas;

            canvas.addEventListener("touchstart", (e) => this.onTouchStart(e));
            canvas.addEventListener("touchmove", (e) => this.onTouchMove(e));
            canvas.addEventListener("touchend", () => this.onTouchEnd());
        },
        onTouchStart(e) {
            if (e.touches.length === 1) {
            this.internalState.previousState = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
            };
            } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            this.internalState.previousState = {
                pinchDistance: Math.sqrt(dx * dx + dy * dy),
            };
            }
        },
        onTouchMove(e) {
            const prev = this.internalState.previousState;
            if (!prev) return;

            if (e.touches.length === 1) {
            const dx = e.touches[0].clientX - prev.x;
            const dy = e.touches[0].clientY - prev.y;
            this.el.emit("gesture-drag", { deltaX: dx, deltaY: dy });
            this.internalState.previousState = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
            };
            } else if (e.touches.length === 2 && prev.pinchDistance) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const scaleChange = distance / prev.pinchDistance;
            this.el.emit("gesture-pinch", { scaleChange });
            this.internalState.previousState.pinchDistance = distance;
            }
        },
        onTouchEnd() {
            this.internalState.previousState = null;
        },
        });

        // === Gesture Handler ===
        AFRAME.registerComponent("gesture-handler", {
        schema: { enabled: { default: true } },
        init: function () {
            this.scaleFactor = 1;
            this.rotation = { x: 0, y: 0 };

            this.handlePinch = this.handlePinch.bind(this);
            this.handleDrag = this.handleDrag.bind(this);

            this.el.sceneEl.addEventListener("gesture-pinch", this.handlePinch);
            this.el.sceneEl.addEventListener("gesture-drag", this.handleDrag);
        },
        remove: function () {
            this.el.sceneEl.removeEventListener("gesture-pinch", this.handlePinch);
            this.el.sceneEl.removeEventListener("gesture-drag", this.handleDrag);
        },
        handlePinch: function (e) {
            if (!this.data.enabled) return;
            this.scaleFactor *= e.detail.scaleChange;
            this.scaleFactor = Math.min(Math.max(this.scaleFactor, 0.05), 5);
            this.el.object3D.scale.set(
            this.scaleFactor,
            this.scaleFactor,
            this.scaleFactor
            );
        },
        handleDrag: function (e) {
            if (!this.data.enabled) return;
            this.rotation.y += e.detail.deltaX * 0.5;
            this.rotation.x += e.detail.deltaY * 0.5;
            this.rotation.x = Math.max(Math.min(this.rotation.x, 90), -90);

            this.el.object3D.rotation.set(
            THREE.MathUtils.degToRad(this.rotation.x),
            THREE.MathUtils.degToRad(this.rotation.y),
            0
            );
        },
        });

        // === Marker Events + Menu ===
        window.addEventListener("DOMContentLoaded", () => {
        const marker = document.querySelector("a-marker");
        const infoButton = document.getElementById("infoButton");
        const infoPopup = document.getElementById("infoPopup");
        const closeInfo = document.getElementById("closeInfo");
        const menu = document.getElementById("menu");

        marker.addEventListener("markerFound", () => {
            infoButton.style.display = "block";
            menu.style.display = "block";
        });

        marker.addEventListener("markerLost", () => {
            infoButton.style.display = "none";
            infoPopup.style.display = "none";
            menu.style.display = "none";
        });

        infoButton.addEventListener("click", () => {
            infoPopup.style.display = "block";
        });

        closeInfo.addEventListener("click", () => {
            infoPopup.style.display = "none";
        });
        });

        function showModel(selectedId) {
        const models = ["keris1", "keris2", "keris3"];
        models.forEach(id => {
            const el = document.getElementById(id);
            el.setAttribute("visible", id === selectedId);
        });
        }
    </script>
</head>
<body>
    <a-scene 
    vr-mode-ui="enabled: false"
    embedded
    arjs="sourceType: webcam; debugUIEnabled: false;"
    gesture-detector>
        <a-entity id="keris1"
                gltf-model="simple_keris.glb"
                scale="0.1 0.1 0.1"
                position="0 0.5 0"
                rotation="90 90 0"
                visible="true"
                gesture-handler></a-entity>
    </a-scene>
</body>
</html>
